# Реалізація інформаційного та програмного забезпечення

## SQL-скрипт для створення на початкового наповнення бази даних

```mysql
-- MySQL Script generated by MySQL Workbench
-- Fri Oct 20 09:55:08 2023
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema db_coursework
-- -----------------------------------------------------
DROP SCHEMA IF EXISTS `db_coursework` ;

-- -----------------------------------------------------
-- Schema db_coursework
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `db_coursework` DEFAULT CHARACTER SET utf8 ;

USE `db_coursework` ;

-- -----------------------------------------------------
-- Table `db_coursework`.`Role`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Role` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Role` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `description` VARCHAR(180) NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Permission`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Permission` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Permission` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `action` VARCHAR(45) NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Project`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Project` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Project` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `description` VARCHAR(180) NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Team`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Team` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Team` (
  `id` INT NOT NULL,
  `name` VARCHAR(100) NULL,
  `motto` VARCHAR(255) NULL,
  `Project_id` INT NOT NULL,
  INDEX `fk_Team_Project1_idx` (`Project_id` ASC) VISIBLE,
  PRIMARY KEY (`id`),
  CONSTRAINT `fk_Team_Project1`
    FOREIGN KEY (`Project_id`)
    REFERENCES `db_coursework`.`Project` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`User`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`User` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`User` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `nickname` VARCHAR(45) NOT NULL,
  `email` VARCHAR(45) NOT NULL,
  `password` VARCHAR(45) NOT NULL,
  `photo` VARCHAR(255) NULL DEFAULT NULL,
  `is_banned` TINYINT NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Collaborator`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Collaborator` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Collaborator` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `Role_id` INT NOT NULL,
  `User_id` INT NOT NULL,
  `Team_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Member_Role1_idx` (`Role_id` ASC) VISIBLE,
  INDEX `fk_Member_User1_idx` (`User_id` ASC) VISIBLE,
  INDEX `fk_Collaborator_Team1_idx` (`Team_id` ASC) VISIBLE,
  CONSTRAINT `fk_Member_Role1`
    FOREIGN KEY (`Role_id`)
    REFERENCES `db_coursework`.`Role` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Member_User1`
    FOREIGN KEY (`User_id`)
    REFERENCES `db_coursework`.`User` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Collaborator_Team1`
    FOREIGN KEY (`Team_id`)
    REFERENCES `db_coursework`.`Team` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Sprint`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Sprint` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Sprint` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `goal` VARCHAR(100) NOT NULL,
  `startdate` DATETIME NULL DEFAULT NULL,
  `enddate` DATETIME NULL DEFAULT NULL,
  `Project_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Sprint_Project1_idx` (`Project_id` ASC) VISIBLE,
  CONSTRAINT `fk_Sprint_Project1`
    FOREIGN KEY (`Project_id`)
    REFERENCES `db_coursework`.`Project` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Tag`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Tag` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Tag` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `description` VARCHAR(180) NULL DEFAULT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Task`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Task` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Task` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(45) NOT NULL,
  `description` VARCHAR(180) NULL DEFAULT NULL,
  `deadline` DATETIME NULL DEFAULT NULL,
  `creation_date` DATETIME NOT NULL,
  `Sprint_id` INT NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Task_Sprint1_idx` (`Sprint_id` ASC) VISIBLE,
  CONSTRAINT `fk_Task_Sprint1`
    FOREIGN KEY (`Sprint_id`)
    REFERENCES `db_coursework`.`Sprint` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Assignment`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Assignment` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Assignment` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `datatime` DATETIME NULL DEFAULT NULL,
  `Collaborator_id` INT NOT NULL,
  `Task_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Assignment_Member1_idx` (`Collaborator_id` ASC) VISIBLE,
  INDEX `fk_Assignment_Task1_idx` (`Task_id` ASC) VISIBLE,
  CONSTRAINT `fk_Assignment_Member1`
    FOREIGN KEY (`Collaborator_id`)
    REFERENCES `db_coursework`.`Collaborator` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Assignment_Task1`
    FOREIGN KEY (`Task_id`)
    REFERENCES `db_coursework`.`Task` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Task_comment`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Task_comment` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Task_comment` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `subject` VARCHAR(45) NOT NULL,
  `text` VARCHAR(45) NOT NULL,
  `datetime` DATETIME NULL DEFAULT NULL,
  `Author_id` INT NOT NULL,
  `Task_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_Task_comment_Member1_idx` (`Author_id` ASC) VISIBLE,
  INDEX `fk_Task_comment_Task1_idx` (`Task_id` ASC) VISIBLE,
  CONSTRAINT `fk_Task_comment_Member1`
    FOREIGN KEY (`Author_id`)
    REFERENCES `db_coursework`.`Collaborator` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Task_comment_Task1`
    FOREIGN KEY (`Task_id`)
    REFERENCES `db_coursework`.`Task` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Grant`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Grant` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Grant` (
  `Role_id` INT NOT NULL,
  `Permission_id` INT NOT NULL,
  INDEX `fk_Grant_Role_idx` (`Role_id` ASC) VISIBLE,
  PRIMARY KEY (`Role_id`, `Permission_id`),
  INDEX `fk_Grant_Permission2_idx` (`Permission_id` ASC) VISIBLE,
  CONSTRAINT `fk_Grant_Role0`
    FOREIGN KEY (`Role_id`)
    REFERENCES `db_coursework`.`Role` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Grant_Permission2`
    FOREIGN KEY (`Permission_id`)
    REFERENCES `db_coursework`.`Permission` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Label`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Label` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Label` (
  `Task_id` INT NOT NULL,
  `Tag_id` INT NOT NULL,
  PRIMARY KEY (`Task_id`, `Tag_id`),
  INDEX `fk_Label_Tag1_idx` (`Tag_id` ASC) VISIBLE,
  CONSTRAINT `fk_Label_Task1`
    FOREIGN KEY (`Task_id`)
    REFERENCES `db_coursework`.`Task` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Label_Tag1`
    FOREIGN KEY (`Tag_id`)
    REFERENCES `db_coursework`.`Tag` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `db_coursework`.`Action`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `db_coursework`.`Action` ;

CREATE TABLE IF NOT EXISTS `db_coursework`.`Action` (
  `date` DATETIME NULL DEFAULT NULL,
  `Sprint_id` INT NOT NULL,
  `Task_id` INT NOT NULL,
  `Assignment_id` INT NOT NULL,
  `Collaborator_id` INT NOT NULL,
  PRIMARY KEY (`Sprint_id`, `Task_id`, `Assignment_id`, `Collaborator_id`),
  INDEX `fk_Action_Task1_idx` (`Task_id` ASC) VISIBLE,
  INDEX `fk_Action_Assignment1_idx` (`Assignment_id` ASC) VISIBLE,
  INDEX `fk_Action_Collaborator1_idx` (`Collaborator_id` ASC) VISIBLE,
  CONSTRAINT `fk_Action_Sprint1`
    FOREIGN KEY (`Sprint_id`)
    REFERENCES `db_coursework`.`Sprint` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Action_Task1`
    FOREIGN KEY (`Task_id`)
    REFERENCES `db_coursework`.`Task` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Action_Assignment1`
    FOREIGN KEY (`Assignment_id`)
    REFERENCES `db_coursework`.`Assignment` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_Action_Collaborator1`
    FOREIGN KEY (`Collaborator_id`)
    REFERENCES `db_coursework`.`Collaborator` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;


-- Додавання тестових даних




-- Початок транзакції
START TRANSACTION;

-- Додавання даних в таблицю `db_coursework`.`Permission`
INSERT INTO `db_coursework`.`Permission` (`action`)
VALUES
    -- collaborator
    ('EditUser'),
    ('CreateTask'),
    ('EditTask'),
    ('DeleteTask'),
    ('FilterTask'),
    ('CommentTask'),
    -- teamlead
    ('CreateProject'),
    ('DeleteProject'),
    ('CreateSprint'),
    ('FinishSprint'),
    ('AddMember'),
    ('DeleteMember'),
    -- admin
    ('UserSupport'),
    ('BanUser'),
    ('UnBanUser');


-- Додавання даних в таблицю `db_coursework`.`Role`
INSERT INTO `db_coursework`.`Role` (`name`, `description`)
VALUES
    ('Administrator', 'Administrator role'),
    ('Team-lead', 'Team-lead role'),
    ('Collaborator', 'Developer role');

-- Додавання даних в таблицю `db_coursework`.`Grant`
INSERT INTO `db_coursework`.`Grant` (`Role_id`, `Permission_id`)
VALUES
    (1, 1),
    (1, 2),
    (1, 3),
    (1, 4),
    (1, 5),
    (1, 6),
    (1, 7),
    (1, 8),
    (1, 9),
    (1, 10),
    (1, 11),
    (1, 12),
    (1, 13),
    (1, 14),
    (1, 15),

    (2, 1),
    (2, 2),
    (2, 3),
    (2, 4),
    (2, 5),
    (2, 6),
    (2, 7),
    (2, 8),
    (2, 9),
    (2, 10),
    (2, 11),
    (2, 12),

    (3, 1),
    (3, 2),
    (3, 3),
    (3, 4),
    (3, 5),
    (3, 6);


-- Додавання даних в таблицю `db_coursework`.`Project`
INSERT INTO `db_coursework`.`Project` (`name`, `description`)
VALUES
    ('Project 1', 'Description for Project 1'),
    ('Project 2', 'Description for Project 2');

-- Додавання даних в таблицю `db_coursework`.`Team`
INSERT INTO `db_coursework`.`Team` (`id`, `name`, `motto`, `Project_id`)
VALUES
    (1, 'Team 1', 'Motto for Team 1', 1),
    (2, 'Team 2', 'Motto for Team 2', 2);

-- Додавання даних в таблицю `db_coursework`.`User`
INSERT INTO `db_coursework`.`User` (`nickname`, `email`, `password`, `photo`, `is_banned`)
VALUES
    ('User1', 'user1@example.com', 'password1', 'link.com/photo', 0),
    ('User2', 'user2@example.com', 'password2', 'link.com/photo', 0);

-- Додавання даних в таблицю `db_coursework`.`Collaborator`
INSERT INTO `db_coursework`.`Collaborator` (`Role_id`, `User_id`, `Team_id`)
VALUES
    (1, 1, 1),  -- Admin User 1 in Team 1
    (2, 2, 2);  -- Manager User 2 in Team 2

-- Додавання тестових даних в таблицю `db_coursework.Sprint`
INSERT INTO `db_coursework`.`Sprint` (`name`, `goal`, `startdate`, `enddate`, `Project_id`)
VALUES
    ('Sprint 1', 'Complete Task 1', '2023-10-18 10:00:00', '2023-10-22 18:00:00', 1),
    ('Sprint 2', 'Finish Project 2', '2023-10-25 09:00:00', '2023-10-29 17:00:00', 2),
    ('Sprint 3', 'Implement Feature 3', '2023-11-01 08:00:00', '2023-11-05 16:00:00', 1);


-- Додавання даних в таблицю `db_coursework`.`Task`
INSERT INTO `db_coursework`.`Task` (`name`, `description`, `deadline`, `creation_date`, `Sprint_id`)
VALUES
    ('Task 1', 'Description for Task 1', '2023-10-31 12:00:00', NOW(), 1),
    ('Task 2', 'Description for Task 2', '2023-11-15 14:30:00', NOW(), 2),
    ('Task 3', 'Description for Task 3', '2023-11-20 10:00:00', NOW(), 3);

-- Додавання тестових даних в таблицю `db_coursework.Assignment`
INSERT INTO `db_coursework`.`Assignment` (`datatime`, `Collaborator_id`, `Task_id`)
VALUES
    ('2023-10-18 11:30:00', 1, 1),
    ('2023-10-19 14:15:00', 2, 2),
    ('2023-10-20 09:45:00', 1, 3);


COMMIT;

```

## RESTfull сервіс для управління даними

**Діаграми Java класів:**

![diagram](https://github.com/mibal-ua/databases-course-work/assets/59470968/2c6fc39e-da10-41e0-bc56-46e45976da97)


### Entities:

**Assignment.java**
```java
package ua.mibal.demo.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * @author Mykhailo Balakhon
 * @link <a href="mailto:9mohapx9@gmail.com">email</a>
 */
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "Assignment")
public class Assignment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "datetime")
    private LocalDateTime localDateTime;

    @Column(name = "Collaborator_id", nullable = false)
    private Long collaboratorId;

    @Column(name = "Task_id", nullable = false)
    private Long taskId;
}
```

**TaskComment.java**
```java
package ua.mibal.demo.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * @author Mykhailo Balakhon
 * @link <a href="mailto:9mohapx9@gmail.com">email</a>
 */
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "Task_comment")
public class TaskComment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "subject", nullable = false)
    private String subject;

    @Column(name = "text", nullable = false)
    private String text;

    @Column(name = "dateTime")
    private LocalDateTime localDateTime;

    @Column(name = "Author_id", nullable = false)
    private Long authorId;

    @Column(name = "Task_id", nullable = false)
    private Long taskId;
}
```
### Repositories

**AssignmentRepository.java**
```java
package ua.mibal.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ua.mibal.demo.model.Assignment;

/**
 * @author Mykhailo Balakhon
 * @link <a href="mailto:9mohapx9@gmail.com">email</a>
 */
public interface AssignmentRepository extends JpaRepository<Assignment, Long> {
}
```

**TaskCommentRepository.java**
```java
package ua.mibal.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ua.mibal.demo.model.TaskComment;

/**
 * @author Mykhailo Balakhon
 * @link <a href="mailto:9mohapx9@gmail.com">email</a>
 */
public interface TaskCommentRepository extends JpaRepository<TaskComment, Long> {
}
```

### Generated Automatically by Spring Controllers

**RepositoryEntityController.java**
```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.data.rest.webmvc;

import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.data.domain.Sort;
import org.springframework.data.mapping.PersistentEntity;
import org.springframework.data.querydsl.binding.QuerydslPredicate;
import org.springframework.data.repository.support.RepositoryInvoker;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.core.event.AfterCreateEvent;
import org.springframework.data.rest.core.event.AfterDeleteEvent;
import org.springframework.data.rest.core.event.AfterSaveEvent;
import org.springframework.data.rest.core.event.BeforeCreateEvent;
import org.springframework.data.rest.core.event.BeforeDeleteEvent;
import org.springframework.data.rest.core.event.BeforeSaveEvent;
import org.springframework.data.rest.core.mapping.ResourceMetadata;
import org.springframework.data.rest.core.mapping.ResourceType;
import org.springframework.data.rest.core.mapping.SearchResourceMappings;
import org.springframework.data.rest.core.mapping.SupportedHttpMethods;
import org.springframework.data.rest.webmvc.support.BackendId;
import org.springframework.data.rest.webmvc.support.DefaultedPageable;
import org.springframework.data.rest.webmvc.support.ETag;
import org.springframework.data.rest.webmvc.support.RepositoryEntityLinks;
import org.springframework.hateoas.CollectionModel;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.Link;
import org.springframework.hateoas.Links;
import org.springframework.hateoas.PagedModel;
import org.springframework.hateoas.RepresentationModel;
import org.springframework.hateoas.UriTemplate;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

@RepositoryRestController
class RepositoryEntityController implements ApplicationEventPublisherAware {
    private static final String BASE_MAPPING = "/{repository}";
    private static final List<String> ACCEPT_PATCH_HEADERS;
    private static final String ACCEPT_HEADER = "Accept";
    private static final String LINK_HEADER = "Link";
    private final RepositoryEntityLinks entityLinks;
    private final RepositoryRestConfiguration config;
    private final HttpHeadersPreparer headersPreparer;
    private final ResourceStatus resourceStatus;
    private ApplicationEventPublisher publisher;

    @Autowired
    public RepositoryEntityController(RepositoryRestConfiguration config, RepositoryEntityLinks entityLinks, HttpHeadersPreparer headersPreparer) {
        this.entityLinks = entityLinks;
        this.config = config;
        this.headersPreparer = headersPreparer;
        this.resourceStatus = ResourceStatus.of(headersPreparer);
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    @RequestMapping(
        value = {"/{repository}"},
        method = {RequestMethod.OPTIONS}
    )
    public ResponseEntity<?> optionsForCollectionResource(RootResourceInformation information) {
        HttpHeaders headers = new HttpHeaders();
        SupportedHttpMethods supportedMethods = information.getSupportedMethods();
        headers.setAllow(supportedMethods.getMethodsFor(ResourceType.COLLECTION).toSet());
        return new ResponseEntity(headers, HttpStatus.OK);
    }

    @RequestMapping(
        value = {"/{repository}"},
        method = {RequestMethod.HEAD}
    )
    public ResponseEntity<?> headCollectionResource(RootResourceInformation resourceInformation, DefaultedPageable pageable) throws HttpRequestMethodNotSupportedException {
        resourceInformation.verifySupportedMethod(HttpMethod.HEAD, ResourceType.COLLECTION);
        RepositoryInvoker invoker = resourceInformation.getInvoker();
        if (null == invoker) {
            throw new ResourceNotFoundException();
        } else {
            Links links = Links.of(new Link[]{ControllerUtils.getDefaultSelfLink()}).and(this.getCollectionResourceLinks(resourceInformation, pageable));
            HttpHeaders headers = new HttpHeaders();
            headers.add("Link", links.toString());
            return new ResponseEntity(headers, HttpStatus.NO_CONTENT);
        }
    }

    @ResponseBody
    @RequestMapping(
        value = {"/{repository}"},
        method = {RequestMethod.GET}
    )
    public CollectionModel<?> getCollectionResource(@QuerydslPredicate RootResourceInformation resourceInformation, DefaultedPageable pageable, Sort sort, RepresentationModelAssemblers assemblers) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {
        resourceInformation.verifySupportedMethod(HttpMethod.GET, ResourceType.COLLECTION);
        RepositoryInvoker invoker = resourceInformation.getInvoker();
        if (null == invoker) {
            throw new ResourceNotFoundException();
        } else {
            Iterable<?> results = invoker.invokeFindAll(pageable.getPageable());
            ResourceMetadata metadata = resourceInformation.getResourceMetadata();
            return (CollectionModel)assemblers.toCollectionModel(results, metadata.getDomainType()).add(this.getCollectionResourceLinks(resourceInformation, pageable));
        }
    }

    private Links getCollectionResourceLinks(RootResourceInformation resourceInformation, DefaultedPageable pageable) {
        ResourceMetadata metadata = resourceInformation.getResourceMetadata();
        SearchResourceMappings searchMappings = metadata.getSearchResourceMappings();
        Links links = Links.of(new Link[]{Link.of(ProfileController.getPath(this.config, metadata), "profile")});
        return searchMappings.isExported() ? links.and(new Link[]{this.entityLinks.linkFor(metadata.getDomainType()).slash(searchMappings.getPath()).withRel(searchMappings.getRel())}) : links;
    }

    @ResponseBody
    @RequestMapping(
        value = {"/{repository}"},
        method = {RequestMethod.GET},
        produces = {"application/x-spring-data-compact+json", "text/uri-list"}
    )
    public CollectionModel<?> getCollectionResourceCompact(@QuerydslPredicate RootResourceInformation resourceinformation, DefaultedPageable pageable, Sort sort, RepresentationModelAssemblers assemblers) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {
        CollectionModel<?> resources = this.getCollectionResource(resourceinformation, pageable, sort, assemblers);
        Stream var10000 = resources.getContent().stream();
        Objects.requireNonNull(PersistentEntityResource.class);
        var10000 = var10000.map(PersistentEntityResource.class::cast);
        Objects.requireNonNull(resourceinformation);
        Links links = (Links)var10000.map(resourceinformation::resourceLink).reduce(resources.getLinks(), (rec$, xva$0) -> {
            return ((Links)rec$).and(new Link[]{xva$0});
        }, Links::and);
        CollectionModel<?> model = resources instanceof PagedModel ? PagedModel.empty(((PagedModel)resources).getMetadata()) : CollectionModel.empty();
        return (CollectionModel)((CollectionModel)model).add(links);
    }

    @ResponseBody
    @RequestMapping(
        value = {"/{repository}"},
        method = {RequestMethod.POST}
    )
    public ResponseEntity<RepresentationModel<?>> postCollectionResource(RootResourceInformation resourceInformation, PersistentEntityResource payload, PersistentEntityResourceAssembler assembler, @RequestHeader(value = "Accept",required = false) String acceptHeader) throws HttpRequestMethodNotSupportedException {
        resourceInformation.verifySupportedMethod(HttpMethod.POST, ResourceType.COLLECTION);
        return this.createAndReturn(payload.getContent(), resourceInformation.getInvoker(), assembler, this.config.returnBodyOnCreate(acceptHeader));
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.OPTIONS}
    )
    public ResponseEntity<?> optionsForItemResource(RootResourceInformation information) {
        HttpHeaders headers = new HttpHeaders();
        SupportedHttpMethods supportedMethods = information.getSupportedMethods();
        headers.setAllow(supportedMethods.getMethodsFor(ResourceType.ITEM).toSet());
        headers.put("Accept-Patch", ACCEPT_PATCH_HEADERS);
        return new ResponseEntity(headers, HttpStatus.OK);
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.HEAD}
    )
    public ResponseEntity<?> headForItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id, PersistentEntityResourceAssembler assembler) throws HttpRequestMethodNotSupportedException {
        return (ResponseEntity)this.getItemResource(resourceInformation, id).map((it) -> {
            Links links = assembler.toModel(it).getLinks();
            HttpHeaders headers = this.headersPreparer.prepareHeaders(resourceInformation.getPersistentEntity(), it);
            headers.add("Link", links.toString());
            return new ResponseEntity(headers, HttpStatus.NO_CONTENT);
        }).orElseThrow(() -> {
            return new ResourceNotFoundException();
        });
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.GET}
    )
    public ResponseEntity<EntityModel<?>> getItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id, final PersistentEntityResourceAssembler assembler, @RequestHeader HttpHeaders headers) throws HttpRequestMethodNotSupportedException {
        return (ResponseEntity)this.getItemResource(resourceInformation, id).map((it) -> {
            PersistentEntity<?, ?> entity = resourceInformation.getPersistentEntity();
            return this.resourceStatus.getStatusAndHeaders(headers, it, entity).toResponseEntity(() -> {
                return assembler.toFullResource(it);
            });
        }).orElseThrow(() -> {
            return new ResourceNotFoundException();
        });
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.PUT}
    )
    public ResponseEntity<? extends RepresentationModel<?>> putItemResource(RootResourceInformation resourceInformation, PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler, ETag eTag, @RequestHeader(value = "Accept",required = false) String acceptHeader) throws HttpRequestMethodNotSupportedException {
        resourceInformation.verifySupportedMethod(HttpMethod.PUT, ResourceType.ITEM);
        if (payload.isNew()) {
            resourceInformation.verifyPutForCreation();
        }

        RepositoryInvoker invoker = resourceInformation.getInvoker();
        Object objectToSave = payload.getContent();
        eTag.verify(resourceInformation.getPersistentEntity(), objectToSave);
        return payload.isNew() ? this.createAndReturn(objectToSave, invoker, assembler, this.config.returnBodyOnCreate(acceptHeader)) : this.saveAndReturn(objectToSave, invoker, HttpMethod.PUT, assembler, this.config.returnBodyOnUpdate(acceptHeader));
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.PATCH}
    )
    public ResponseEntity<RepresentationModel<?>> patchItemResource(RootResourceInformation resourceInformation, PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler, ETag eTag, @RequestHeader(value = "Accept",required = false) String acceptHeader) throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {
        resourceInformation.verifySupportedMethod(HttpMethod.PATCH, ResourceType.ITEM);
        Object domainObject = payload.getContent();
        eTag.verify(resourceInformation.getPersistentEntity(), domainObject);
        return this.saveAndReturn(domainObject, resourceInformation.getInvoker(), HttpMethod.PATCH, assembler, this.config.returnBodyOnUpdate(acceptHeader));
    }

    @RequestMapping(
        value = {"/{repository}/{id}"},
        method = {RequestMethod.DELETE}
    )
    public ResponseEntity<?> deleteItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id, ETag eTag, PersistentEntityResourceAssembler assembler, @RequestHeader(value = "Accept",required = false) String acceptHeader) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {
        resourceInformation.verifySupportedMethod(HttpMethod.DELETE, ResourceType.ITEM);
        RepositoryInvoker invoker = resourceInformation.getInvoker();
        Optional<Object> domainObj = invoker.invokeFindById(id);
        return (ResponseEntity)domainObj.map((it) -> {
            PersistentEntity<?, ?> entity = resourceInformation.getPersistentEntity();
            eTag.verify(entity, it);
            this.publisher.publishEvent(new BeforeDeleteEvent(it));
            invoker.invokeDeleteById(entity.getIdentifierAccessor(it).getIdentifier());
            this.publisher.publishEvent(new AfterDeleteEvent(it));
            return this.config.returnBodyOnDelete(acceptHeader) ? ResponseEntity.ok(assembler.toFullResource(it)) : new ResponseEntity(HttpStatus.NO_CONTENT);
        }).orElseThrow(() -> {
            return new ResourceNotFoundException();
        });
    }

    private ResponseEntity<RepresentationModel<?>> saveAndReturn(Object domainObject, RepositoryInvoker invoker, HttpMethod httpMethod, PersistentEntityResourceAssembler assembler, boolean returnBody) {
        this.publisher.publishEvent(new BeforeSaveEvent(domainObject));
        Object obj = invoker.invokeSave(domainObject);
        this.publisher.publishEvent(new AfterSaveEvent(obj));
        PersistentEntityResource resource = assembler.toFullResource(obj);
        HttpHeaders headers = this.headersPreparer.prepareHeaders(Optional.of(resource));
        if (HttpMethod.PUT.equals(httpMethod)) {
            this.addLocationHeader(headers, assembler, obj);
        }

        return returnBody ? ControllerUtils.toResponseEntity(HttpStatus.OK, headers, resource) : ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT, headers);
    }

    private ResponseEntity<RepresentationModel<?>> createAndReturn(Object domainObject, RepositoryInvoker invoker, PersistentEntityResourceAssembler assembler, boolean returnBody) {
        this.publisher.publishEvent(new BeforeCreateEvent(domainObject));
        Object savedObject = invoker.invokeSave(domainObject);
        this.publisher.publishEvent(new AfterCreateEvent(savedObject));
        Optional<PersistentEntityResource> resource = Optional.ofNullable(returnBody ? assembler.toFullResource(savedObject) : null);
        HttpHeaders headers = this.headersPreparer.prepareHeaders(resource);
        this.addLocationHeader(headers, assembler, savedObject);
        return ControllerUtils.toResponseEntity(HttpStatus.CREATED, headers, resource);
    }

    private void addLocationHeader(HttpHeaders headers, PersistentEntityResourceAssembler assembler, Object source) {
        String selfLink = assembler.getExpandedSelfLink(source).getHref();
        headers.setLocation(UriTemplate.of(selfLink).expand(new Object[0]));
    }

    private Optional<Object> getItemResource(RootResourceInformation resourceInformation, Serializable id) throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {
        resourceInformation.verifySupportedMethod(HttpMethod.GET, ResourceType.ITEM);
        return resourceInformation.getInvoker().invokeFindById(id);
    }

    static {
        ACCEPT_PATCH_HEADERS = Arrays.asList(RestMediaTypes.MERGE_PATCH_JSON.toString(), RestMediaTypes.JSON_PATCH_JSON.toString(), "application/json");
    }
}
```

